services:
  kafka:
    image: apache/kafka:latest
    container_name: kafka
    ports:
      - "9092:9092"
    environment:
      # KRaft mode configuration
      KAFKA_NODE_ID: 1
      KAFKA_PROCESS_ROLES: broker,controller
      KAFKA_CONTROLLER_QUORUM_VOTERS: 1@kafka:9093
      
      # Listeners
      # 1. CONTROLLER: for internal controller communication (port 9093)
      # 2. INTERNAL: for inter-broker communication (port 9094)
      # 3. EXTERNAL: for localhost access (port 9092)
      KAFKA_LISTENERS: INTERNAL://0.0.0.0:9094,EXTERNAL://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093
      
      # Advertised Listeners
      # - Clients connecting on port 9094 should use the address 'kafka:9094'
      # - Clients connecting on port 9092 should use the address 'localhost:9092'
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka:9094,EXTERNAL://localhost:9092
      
      # Security Protocol Mapping (Protocol used on each Listener)
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: CONTROLLER:PLAINTEXT,INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT
      KAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER
      KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL

      # Single node configuration
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      
      # Memory limits to control hardware usage
      KAFKA_HEAP_OPTS: "-Xms512M -Xmx512M"

      # 12 partitions per topic for equal distribution across 1, 2, 3, 4, 6 or 12 consumers
      KAFKA_NUM_PARTITIONS: 12
    networks:
      - iot_net
    healthcheck:
      test: ["CMD-SHELL", "/opt/kafka/bin/kafka-topics.sh --bootstrap-server kafka:9094 --list"]
      interval: 5s
      timeout: 5s
      retries: 10
      start_period: 10s
  
  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    container_name: kafka-ui
    ports:
      - "8080:8080"
    environment:
      - KAFKA_CLUSTERS_0_NAME=local-cluster
      - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka:9094
    networks:
      - iot_net
    depends_on:
      kafka:
        condition: service_healthy

  cassandra:
    image: cassandra:4.1
    container_name: cassandra
    ports:
      - "9042:9042"
    environment:
      - CASSANDRA_CLUSTER_NAME=iot_cluster
      - CASSANDRA_DC=datacenter1
      - CASSANDRA_ENDPOINT_SNITCH=GossipingPropertyFileSnitch
      
      # Limiting JVM memory, but not too much to avoid message dropping
      - MAX_HEAP_SIZE=1024M
      - HEAP_NEWSIZE=256M
    volumes:
      - cassandra_data:/var/lib/cassandra
    networks:
      - iot_net
    healthcheck:
      test: ["CMD-SHELL", "cqlsh -e 'DESCRIBE KEYSPACES'"]
      interval: 10s
      timeout: 10s
      retries: 10
      start_period: 40s
    
  init-cassandra:
    image: cassandra:4.1
    depends_on:
      cassandra:
        condition: service_healthy
    volumes:
      - ./infra/cassandra/init.cql:/init.cql
    networks:
      - iot_net
    command: >
      bash -c "cqlsh cassandra -f /init.cql"
  
  producer:
    build:
      context: ./app
      dockerfile: Dockerfile
    container_name: producer
    networks:
      - iot_net
    environment:
      - KAFKA_BOOTSTRAP_SERVERS=kafka:9094
    depends_on:
      kafka:
        condition: service_healthy
    command: python iot_producer.py
    restart: on-failure

  consumer:
    build:
      context: ./app
      dockerfile: Dockerfile
    # No container_name to allow scaling
    networks:
      - iot_net
    environment:
      - KAFKA_BOOTSTRAP_SERVERS=kafka:9094
      - CASSANDRA_HOST=cassandra
    depends_on:
      kafka:
        condition: service_healthy
      init-cassandra:
        condition: service_completed_successfully
    command: python iot_consumer.py
    restart: on-failure

networks:
  iot_net:
    driver: bridge

volumes:
  cassandra_data:
